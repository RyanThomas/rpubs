---
title: "Crashes PCA"
author: "Ryan Thomas"
date: "February 1, 2016"
output: html_document
---
###1. First, remind everyone of the structure of your data.
```{r, echo=FALSE, warning=FALSE,message=FALSE}
setwd("~/Documents/r/directories/data")
crashes <- read.table("multivariate_data/crashes.txt", header = T, sep = "\t")

str(crashes)
```
The data represent the number of crashes in each town that have been coded with the corresponding conditions. So, for the second variable in the ```str(crashes)``` output, "Blowing" represents the number of crashes in each town that occurred with blowing debris, including snow, rain, or dust.  

### Then Identify normal variables    
One of the prerequisites for multivariate normal distribution is whether each individual variable is itself normally distributed. The Chi Squared test determines if a dataset is multivariate normal distribution. However, if it is _not_ normally distributed, the Chi Squared test doesn't give any clue as to which variable(s) aren't normally distributed. So it makes sense to first look at each variable individually to test whether it is normally distributed. To do this, we will write a new function, ```qqtest()```, which create the Q-Q Normal polts for each variable in the data. Then from this, we will identify which of the variables have a linear ```qqnorm()``` plot and try taking the log of the others. This should create a 3-column array of plots for any number of variables. 

```{r, warning=FALSE,message=FALSE}
qqtest <- function(x){
    #set up plot for 3 columns and however many rows are needed
  par(mfrow = c(ceiling((ncol(x)-1)/3),3))
    #starting with the second column, loop through the dataset and make qq plots
  for (i in 2:ncol(x)){
    qqnorm(x[,i], main = names(x[i]))
    qqline(x[,i], col = "red")
  }
}


qqtest(crashes)
```

It looks like a number of these variables are not normally distributed, so we will transform them.
```{r}
crashes.log <- data.frame(cbind(log(crashes$None), log(crashes$Blowing), log(crashes$Snow), log(crashes$Rain), log(crashes$SleetHail), log(crashes$Fog), log(crashes$Other)))
names(crashes.log) <- c("log.None", "log.Blowing", "log.Snow", "log.Rain", "log.SleetHail", "log.Fog", "log.Other")

# the log() of 0 is -infinity, so those values can be replaced with a 0.
crashes.log[is.infinite(as.matrix(crashes.log))] <- NA
crashes.log <- crashes.log[complete.cases(crashes.log[,c(1:7)]), c(1:7)]
str(crashes.log)

qqtest(crashes.log)
```

### Now make a Chi Squared plot
Now, all of the variables look to be nearly normally distribtued. Some of the plots have clusters of points on horizontal lines. This is because the data are discrete, rather than truly continuous. Still, this passes a visual test for normality. So we can now use a Chi Squared plot to test our work.
```{r, echo = FALSE, warning = FALSE}
#see if data happens to have multivariate normal dist. 
# (not required but handy for parallel analysis)
#get online function
dev.off()
#A function to make chi-square quantile plots 
#to test for multivariate normality of data or residuals


reschisqplot<-function(vars,label){
   #usually, vars is xxx$residuals or data from one group and label is for plot
     x<-cov(scale(vars),use="pairwise.complete.obs")
     squares<-sort(diag(as.matrix(scale(vars))%*%solve(x)%*%as.matrix(t(scale(vars)))))
     quantiles<-quantile(squares)
     hspr<-quantiles[4]-quantiles[2]
     cumprob<-c(1:length(vars[,1]))/length(vars[,1])-1/(2*length(vars[,1]))
     degf<-dim(x)[1]
     quants<-qchisq(cumprob,df=degf)
     gval<-(quants**(-1+degf/2))/(exp(quants/2)*gamma(degf/2)*(sqrt(2)**degf))
     scale<-hspr / (qchisq(.75,degf)-qchisq(.25,degf))
     se<-(scale/gval)*sqrt(cumprob*(1-cumprob)/length(squares))
     lower<-quants-2*se
     upper<-quants+2*se

    plot(quants,squares,col='red',pch=19,cex=1.2,xlab="Chi-Square Quantiles",
     ylab=label,main=paste("Chi-Square Quantiles for",label),ylim=range(upper,lower, squares) , xlim=range(c(0,quants)))
    lines(c(0,100),c(0,100),col=1)
    lines(quants,upper,col="blue",lty=2,lwd=2)
    lines(quants,lower,col="blue",lty=2,lwd=2)
    legend(0,range(upper,lower)[2]*.9,c("Data","95% Conf Limits"),lty=c(0,2),col=c("red","blue"),lwd=c(2,2),
      pch=c(19,NA))
}

#An example of usage of this function
#reschisqplot(danielaaov$residuals,label="Daniela MANOVA Residuals")
```

```{r}
reschisqplot(crashes.log[,-1],label="CTDOT Crash Data")
```

```{r}
#make correlation matrix to see if PCA will work well
round(cor(crashes.log[,-1]),2)
```


```{r}
#make matrix plot to check for linearity
plot(crashes.log[,-1])
```


```{r}
pc1=princomp(crashes.log[,-1], cor=TRUE)

print(summary(pc1),digits=2,loadings=pc1$loadings,cutoff=0)
```

```{r, warnings = FALSE}
#perform parallel analysis
#get the function online
source("http://www.reuningscherer.net/STAT660/R/parallel.r.txt")

#make the parallel analysis plot
parallelplot(pc1)

#make scoreplot with confidence ellipse : 
#  c(1,2) specifies to use components 1 and 2
#get function from online
source("http://reuningscherer.net/stat660/r/ciscoreplot.R.txt")

#run the function
ciscoreplot(pc1,c(1,2),crashes.log[,1])

#make a biplot for first two components
biplot(pc1,choices=c(1,2),pc.biplot=T)
```

```{r}
library(ggvis)
chol <- read.table(url("http://s3.amazonaws.com/assets.datacamp.com/blog_assets/chol.txt"), header = TRUE)
chol %>%
  ggvis(~AGE) %>%
  layer_histograms(width = input_slider(1, 10, step = 1, label = "Bin Width"), 
                   center = 35, 
                   fill := "#E74C3C") %>% 
  add_axis("x", title = "Age")%>%  
  add_axis("y", title = "Bin Count")
```

